# 2025-08-29 學習日誌

- [x] 讀完 usr_11.txt - Recovering from a crash
- [x] 讀 usr_12.txt - Clever tricks
- [x] kickstart.nvim video & configuration

## 以下是 vim usr_11.txt > 11.1 个說明，我試袂出來

In most cases recovering a file is quite simple, assuming you know which file
you were editing (and the harddisk is still working). Start Vim on the file,
with the "-r" argument added:

```bash
	vim -r help.txt
```

Vim will read the swap file (used to store text you were editing) and may read
bits and pieces of the original file. If Vim recovered your changes you will
see these messages (with different file names, of course):

> Using swap file ".help.txt.swp"
> Original file "~/vim/runtime/doc/help.txt"
> Recovery completed. You should check if everything is OK.
> (You might want to write out this file under another name
> and run diff with the original file to check for changes)
> You may want to delete the .swp file now.

To be on the safe side, write this file under another name:

```vim
	:write help.txt.recovered
```

Compare the file with the original file to check if you ended up with what you
expected. Diff mode is very useful for this |08.7|. For example:

```vim
	:write help.txt.recovered
	:edit #
	:diffsp help.txt
```

## 猶原著用 `DiffOrig` 才是正路

咱扑 `nvim -r help.txt` 个時，伊會將已存个 help.txt 佮 swap file 敆做伙，
予 buffer 改成待存檔狀態，tsit-tsūn正正是咱使用 `:DiffOrig` 个時機！
用伊頂頭个指令，顛倒顯示袂出舊檔佮融入swap个新檔个差別。

## swap 操作相關个指令佮 options

usr_11.txt 11.4 列出一个參考指令表：

|swap-file|: An explanation about where the swap file will be created and
what its name is.

|:preserve|: Manually flushing the swap file to disk.

|:swapname|: See the name of the swap file for the current file.

'updatecount': Number of key strokes after which the swap file is flushed to
disk.

'updatetime': Timeout after which the swap file is flushed to disk.

'directory': List of directory names where to store the swap file.

## usr_12.txt - Clever tricks

### 12.1 Replace a word

1. word boundary: `:%s/\<four\>/4/gc`

2. not finding a match is not an error: `:%s/\<GetResp\>/GetAnswer/ge`

### usr_12.txt 12.1 some vim regex symbols

1. capturing group: `\(xyz\)`
2. backreference: `\0` whole match, `\1` group 1, `\2` group 2, etc.
3. or: `\|`
4. quantifier for one or more characters: `\+```

### usr_12.txt 12.4 Reverse the order of a range of lines

First move to above the first line and mark it with "mt".
Then move the cursor to the last line in the range and type:

```vim
:'t+1,.g/^/m 't
```

### usr_12.txt 12.5 Count words

`g<C-g>` 袂輸是 nvim 中个 `wc` 指令。

## kickstart.nvim video & configuration

看作者 TJ DeVries 佇 Youtube 紹介 kickstart.mvim 个影片，兩年前伊就做過一集，
用 packer 包裝 plugins，一年前閣做一集，就改用 lazy.nvim 矣。

### restore cursor position

### AI convert Vimscript to Lua code

以下是 AI 協助个過程，其實 AstroNvim 有寫一段 Lua code 較簡捷。

USER:  
Help me convert the following vimscript code into lua code for putting the
cursor at the last known position when reopening a file.

```vimscript
    augroup RestoreCursor
      autocmd!
      autocmd BufReadPre * autocmd FileType <buffer> ++once
        \ let s:line = line("'\"")
        \ | if s:line >= 1 && s:line <= line("$") && &filetype !~# 'commit'
        \      && index(['xxd', 'gitrebase'], &filetype) == -1
        \ |   execute "normal! g`\""
        \ | endif
    augroup END
```

AGENT:  
I'll help you convert that Vimscript code to Lua for Neovim. This code restores
the cursor position to where it was when you last closed the file.

Here's the Lua equivalent:

```lua
vim.api.nvim_create_augroup('RestoreCursor', { clear = true })

vim.api.nvim_create_autocmd('BufReadPre', {
  group = 'RestoreCursor',
  pattern = '*',
  callback = function(args)
    vim.api.nvim_create_autocmd('FileType', {
      buffer = args.buf,
      once = true,
      callback = function()
        local mark = vim.api.nvim_buf_get_mark(0, '"')
        local line = mark[1]
        local line_count = vim.api.nvim_buf_line_count(0)
        
        if line >= 1 and line <= line_count then
          local filetype = vim.bo.filetype
          if not filetype:match('commit') 
             and filetype ~= 'xxd' 
             and filetype ~= 'gitrebase' then
            vim.cmd('normal! g`"')
          end
        end
      end
    })
  end
})
```

Here's a breakdown of the conversion:

1. **Autogroup creation**: `augroup RestoreCursor` becomes
   `vim.api.nvim_create_augroup('RestoreCursor', { clear = true })`

2. **BufReadPre autocmd**: The outer autocmd is created with
   `vim.api.nvim_create_autocmd('BufReadPre', ...)`

3. **Nested FileType autocmd**: The `autocmd FileType <buffer> ++once` becomes
   a nested autocmd created in the callback, with `once = true` and `buffer =
   args.buf`

4. **Getting the last position**: `line("'\"")` becomes
   `vim.api.nvim_buf_get_mark(0, '"')` which returns a table where the first
   element is the line number

5. **Line count**: `line("$")` becomes `vim.api.nvim_buf_line_count(0)`

6. **Filetype checking**: `&filetype` becomes `vim.bo.filetype`, and the
   pattern matching and array indexing are converted to Lua equivalents

7. **Executing the jump**: `execute "normal! g`\""` becomes
   `vim.cmd('normal! g`"')`

This Lua code does exactly the same thing as your Vimscript: it sets up an
autocommand that runs when a buffer is read, which then sets up a one-time
FileType autocommand that restores the cursor position if appropriate
(excluding commit messages, xxd, and gitrebase files).

You can add this to your Neovim Lua configuration file (e.g., in your
`init.lua` or in a separate module that gets required).


User: BTW, what's the meaning of the operator `!~#` in
      `&filetype !~# 'commit'`?

Agent: The operator `!~#` in Vimscript is a case-sensitive regex non-matching
       operator. Let me break it down:

- `~` is the regex matching operator
- `!~` means "does NOT match" (the `!` negates the match)
- The `#` suffix makes it case-sensitive

So `&filetype !~# 'commit'` means: "the filetype does NOT match
(case-sensitive) the pattern 'commit'"

Here are the different regex operators in Vimscript:

| Operator | Meaning | Case Sensitivity |
|----------|---------|------------------|
| `=~` | matches regex | depends on 'ignorecase' setting |
| `!~` | does NOT match regex | depends on 'ignorecase' setting |
| `=~#` | matches regex | always case-sensitive |
| `!~#` | does NOT match regex | always case-sensitive |
| `=~?` | matches regex | always case-insensitive |
| `!~?` | does NOT match regex | always case-insensitive |

In the context of your code, `&filetype !~# 'commit'` will return true if the
filetype does NOT contain the word "commit" anywhere in it. This would exclude
filetypes like:
- `gitcommit`
- `svncommit`
- `hgcommit`

That's why in my Lua translation, I used `not filetype:match('commit')` which
achieves the same effect - it checks if the filetype string does not contain
"commit" as a substring.
