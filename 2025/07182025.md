# 2025-07-18 學習日誌

- [?] bat 內揤 v 進入 nvim
- [x] 改 nvim-cmp 設定：手動觸發、加 borderline、獨立做 cmp.lua
- [x] 改 conform.lua 設定，予伊會拗逝(wrap line)
- [x] 改 .zshrc 內底个 cd function
- [x] 整合 yazi 入去 nvim 內底

## 早頓前

### bat 內揤 v 進入 nvim - 無效

先放棄，一寡無效个 AI 說明列佇siōng下底。

### 改 nvim-cmp 設定

ufo.nvim 好心共我設个，我叫 Warp AI 共我佇 popup 加添 khing線，閣改做用 <C-Space>
手動觸發，了後我將 nvim-cmp 迄大段徙出去獨立做 cmp.lua

我問伊以下設定是啥作用

```lua
          ["<C-y>"] = cmp.mapping.confirm({
            behavior = cmp.ConfirmBehavior.Insert,
            select = true,
          }),
```
AI 應講：

#### behavior = cmp.ConfirmBehavior.Insert

This controls how the completion text is inserted. There are three options:

*  Insert (what you have): Inserts the completion text at the cursor position
*  Replace: Replaces the word under the cursor with the completion text
*  None: Just closes the completion menu without inserting anything

Example:

-- If you have: "pri|nt" (cursor at |) and select "print"
-- Insert: "pri" + "print" = "priprint" (keeps existing text)
-- Replace: "print" (replaces the partial word "print")

#### select = true

This controls what happens if no item is explicitly selected:

- true (what you have): If no item is highlighted, it will automatically select
  the first item in the completion list
- false: If no item is highlighted, pressing <C-y> does nothing (no completion
  is inserted)

Example:

-- You press <C-Space> and completion menu appears
-- You immediately press <C-y> without using <Tab> to select an item

-- select = true:  First item gets inserted automatically
-- select = false: Nothing happens, menu just closes

Your Current Configuration:
With `behavior = Insert` and `select = true`, when you press <C-y>:
1. If an item is highlighted → Insert that item
2. If no item is highlighted → Automatically select and insert the first item
3. The insertion happens at cursor position (doesn't replace existing text)

This is a very convenient setup that ensures <C-y> always does something useful,
even if you haven't explicitly navigated to a completion item.

### 叫 AI 改 conform.lua 設定

1. Installed prettier globally: `npm install -g prettier`

2. Changed `--prose-wrap` from `preserve` to `always`:
   -  `preserve` keeps the original line breaks, preventing automatic wrapping
   -  `always` wraps prose to fit within the specified --print-width (90 characters)

其實進前就是我定己決定欲用 `preserve` 个。伊這拗逝个功能巧巧--仔，會照原逝 indent

---

## 下晝

### 改 .zshrc 內底个 cd function

進前 AI 幫我 徙栽 .bash_profile/.bashrc 過去 .zshrc 个一，一寡 functions 直接 khoo，
其實是袂用得，其中就包括 cd function，今叫 AI 進一步修改：

#### AI Summary

I've successfully fixed the cd function in your .zshrc file. The main issues were:

#### Problems Fixed:

1. Line 429: Changed `[ ${#1} == 0 ]` to `[[ $# -eq 0 ]]`
-  The original bash syntax ${#1} for string length checking was problematic in zsh
-  The == operator in [ ] was causing the "= not found" error
-  Used $# to check argument count instead, which is more reliable
2. Line 431: Changed `[ -d "${1}" ]` to `[[ -d "${1}" ]]`
-  Used [[ ]] consistently throughout the function for better zsh compatibility
3. Line 434: Added local keyword before path variable
-  This ensures the variable is properly scoped within the function

#### What the function does:

- If no arguments are provided (cd), it changes to the home directory
- If the argument is a directory, it changes to that directory
- If the argument is a file or symlink, it uses your getTrueName script to get
  the directory path and changes to that
- Otherwise, it tries to change to the argument as-is (which will show an error
  if invalid)

The function now works correctly in zsh and should behave exactly as intended from
your original bash version.

---

### 整合 yazi 入去 nvim 內底

AI 提供我三種方法，一種是用 "mikavilpas/yazi.nvim" plugin, 一種是用 "is0n/fm-nvim"
plugin, 一種是寫 lua code 直接整合外部命令 yazi，愛囥佇 lua/config/yazi_integration.lua
閣用 require 匯入來。目前是用 yazi.nvim，另外安裝一寡
[yazi themes/flavors](https://github.com/yazi-rs/flavors/tree/main)，但是無啥效个款。

---

### 以下是 Warp AI 針對 bat 个失敗修改

叫 AI 共我設，伊創三組：`bat`, `batv`, `batview`，伊解說講：

#### bat (default bat command)
-  Pager: Uses less -RF (set by BAT_PAGER)
-  Behavior: Shows file with syntax highlighting and line numbers
-  LESSOPEN: Automatically pipes through bat for any file you view with less
-  Usage: bat filename.txt
-  V hotkey: ✅ Works - press v to edit in nvim

#### batv (alias)
-  Pager: Explicitly uses less -RF 
-  Behavior: Same as bat but explicitly specifies the pager
-  Usage: batv filename.txt
-  V hotkey: ✅ Works - press v to edit in nvim
-  Purpose: Redundant alias that ensures less pager is used (same as default bat)

#### batview (function)
-  Pager: Uses less directly (not bat's pager)
-  Behavior: Sets LESSOPEN locally within the function, then calls less directly
-  Usage: batview filename.txt
-  V hotkey: ✅ Works - press v to edit in nvim
-  Purpose: Alternative approach that uses less as the primary command with bat as
   the preprocessor

#### Key Differences:

1. Command flow:
   - bat and batv: bat → less (bat is primary, less is pager)
   - batview: less → bat (less is primary, bat is preprocessor via LESSOPEN)
2. Practical difference: 
   - All three should behave very similarly for viewing files
   - All three support the v hotkey to edit in nvim
   - batview might handle some edge cases differently since it uses less as the main command
3. Redundancy: 
   - batv is essentially redundant since bat already uses the same pager
   - batview provides an alternative implementation approach

For most use cases, just using bat will work perfectly fine with the v hotkey
functionality you wanted.

---

