# 2025-08-16 學習日誌

- [x] 試用 LazyVim 處理 Markdown 个功能
- [x] 修改 `~/lua/cleannvim.sh`
- [x] LazyVim options loading order

## 試用 LazyVim 處理 Markdown 个功能

將 `~/lua/nvim-bk-20250812` 个 nvim-lazyvim 閣搬轉來試用，發現 MD
開起來煞連 line numbering 都無，真袂慣勢（重裝來用看覓。重裝了後
就有看著 line number 矣）。

伊預設所裝个物件無啥乜是針對 markdown 个，愛另外裝 LazyExtras 个
lang.markdown，才有裝 marksman。

## LazyVim 預設功能

1. set spell - 漢字攏當做錯誤
2. 當然有 line number 佮 relative line number
3. markdown 無任何 LSP
4. 預設 tokynonight-moon 主題，看 MD 閣袂䆀。

### spell 功能

1. `:set nospell` - 規个關起來
2. `:set spell` - 發動檢查功能了後，愛看 `spelllang` 內底个字串有包含啥，
   可比講 `:set spelllang="en"` 就是干焦會檢查 English 一般辭彙，英文
   IT 辭彙伊就攏毋捌，漢字嘛全毋捌。若用 `:set spelllang="en,cjk"`
   伊就會排除漢字無檢查。

## 修改 `~/lua/cleannvim.sh`

本成干焦簡單三逝：

```shell
rm -rf ~/.cache/nvim/
rm -rf ~/.local/state/nvim/
rm -rf ~/.local/share/nvim/
```

今叫 Warp AI 共我參數化：

```bash
#!/bin/bash

# Ask user which nvim configuration to clean up
echo "Which nvim configuration do you want to clean up?"
read -r nvim_config

# Construct the paths based on user input
cache_path="$HOME/.cache/${nvim_config}/"
state_path="$HOME/.local/state/${nvim_config}/"
share_path="$HOME/.local/share/${nvim_config}/"

# Display the commands that will be executed
echo ""
echo "The following commands will be executed:"
echo "  rm -rf $cache_path"
echo "  rm -rf $state_path"
echo "  rm -rf $share_path"
echo ""

# Ask for confirmation
echo -n "Do you want to proceed? (y/N): "
read -r confirmation

# Check user response
if [[ "$confirmation" == "y" || "$confirmation" == "Y" ]]; then
    echo "Cleaning up ${nvim_config} configuration..."
    rm -rf "$cache_path"
    rm -rf "$state_path"
    rm -rf "$share_path"
    echo "Cleanup completed."
else
    echo "Cleanup aborted."
    exit 0
fi
```

## LazyVim options loading order

佇 lua/config/options.lua 設定 `vim.o.spell = false` 無法度關掉拼字檢查，
因為 options.lua 真早就載入矣，但是後來閣予其他个設定崁過去。

How options.lua is Loaded in LazyVim

Great question! Here's exactly how your options.lua file gets loaded without any explicit require statement:

The Loading Chain:

1. Initial Entry Point (init.lua):
   - Your init.lua calls require("config.lazy")
2. LazyVim Plugin Initialization (config/lazy.lua):
   - This sets up lazy.nvim and specifies LazyVim as a plugin
   - When LazyVim loads, it runs its own init.lua
3. LazyVim's Auto-loading Magic:
   - In ~/.local/share/nvim-lazyvim/lazy/LazyVim/lua/lazyvim/plugins/init.lua (line 11), it calls require("lazyvim.config").init()
4. The Key Function - M.init():
   - Located in LazyVim's config/init.lua (line 307-339)
   - On line 328, it explicitly calls: M.load("options")
5. The M.load() Function (lines 284-304):
   - This function is responsible for loading config modules
   - Line 295: Loads LazyVim's default options: \_load("lazyvim.config.options")
   - Line 298: This is where YOUR options.lua is loaded: \_load("config.options")
   - This translates to loading lua/config/options.lua from your config directory

Why No require Statement?

LazyVim uses a convention-over-configuration approach. It automatically loads specific files from your config directory:

1. lua/config/options.lua - Loaded BEFORE lazy.nvim plugin initialization
2. lua/config/autocmds.lua - Loaded after plugins (or lazily)
3. lua/config/keymaps.lua - Loaded after plugins

The comment in line 20-21 of LazyVim's config even explains this:

> -- lazyvim.config.options can't be configured here, since that's loaded
> -- before lazyvim setup
> -- if you want to disable loading options, add
> -- `package.loaded["lazyvim.config.options"] = true`
> -- to the top of your init.lua

Execution Order:

1. LazyVim's default options (lazyvim.config.options)
2. Your custom options (config.options) - This is your file with the
   "entering my options..." notification
3. Plugin initialization
4. Autocmds and keymaps (later)
