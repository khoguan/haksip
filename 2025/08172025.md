# 2025-08-17 學習日誌

- [x] Hak 目錄行長縮小
- [x] Lua diagnostics: Undefined field `get`
- [x] neo-tree multiple copy/cut/paste
- [x] selene 設定檔 selene.toml 佮 neovim.yml
- [x] 重裝、重整 AstroNvim

## Hak 目錄行長縮小

因為時常愛兩个視窗左右並列做比較，所以將行長縮短。

1. `lua/plugins/astrocore.lua` 內底 `exrc = true,`
2. `~/Hak` 下底愛加設一个 `.nvimrc`:

```vim
" Directory-specific nvim configuration for ~/Hak
" Sets textwidth=76 for markdown files in this directory only

" Create an autocmd to set textwidth=70 for markdown files in this directory
autocmd FileType markdown setlocal textwidth=76
autocmd FileType markdown setlocal colorcolumn=+1
```

## lua_ls false positive

我：Check `~/.local/share/nvim/lazy/astroui/lua/astroui/status/heirline.lua`.
Line 107 in it will trigger "Lua Diagnostics.: Undefined field `get`." But
actually it will run without errors.

AI: The code is using vim.opt.showtabline:get() which triggers a Lua diagnostics
warning about an undefined field get. This is a false positive from the Lua
language server because vim.opt objects in Neovim do have a get() method at
runtime, but the language server's type definitions might not be aware of this.

### Warp AI solution

Perfect! I've configured your Lua language server to properly understand
Neovim's API, including the vim.opt:get() method. Here's what I did:

Changes Made:

1. Updated .luarc.json: Added comprehensive lua_ls configuration including:
   - Set runtime to LuaJIT (which Neovim uses)
   - Added vim and require to global diagnostics
   - Disabled the undefined-field diagnostic which was causing the false
     positive for vim.opt:get()
   - Disabled missing-fields to reduce other false positives
   - Configured workspace settings
2. Created lua/plugins/lazydev.lua: A dedicated plugin configuration that:
   - Properly configures lazydev.nvim to load Neovim's runtime files and all
     installed plugins
   - Integrates with AstroLSP to apply lua_ls settings
   - Specifically disables the undefined-field diagnostic that was causing the
     issue
   - Adds luvit-meta for better vim.uv support

To Apply the Changes:

1. Restart Neovim or run :Lazy sync to ensure the new plugin configuration is
   loaded
2. Open the problematic file (heirline.lua) again
3. The "Undefined field get" error should now be gone

The key fix was disabling the undefined-field diagnostic in lua_ls. This
diagnostic doesn't understand Neovim's metatable-based vim.opt API where methods
like :get() are dynamically available at runtime. By disabling this specific
diagnostic, you won't get false positives while still maintaining other helpful
diagnostics.

The configuration also improves overall Neovim API recognition through
lazydev.nvim, which will provide better autocompletion and type hints for all
Neovim-specific functions and APIs.

## neo-tree multiple copy/cut/paste

本來我掠叫是著愛隨个隨个檔案先做一个號頭，可比講揤 `<Tab>` 抑是捏 `m`，
了後才決定欲對即堆檔案做啥操作，像 copy/cut/delete 等，後來才知影
拄開始著愛先決定欲 copy 抑是 cut，若欲 copy，就一个仔一个去揤 `y` (yank)
做 `copy_to_clipboard`，遐个檔案後壁就會出現 `(copy)` 个虛文字，
才將光標徙去目的目錄，揤 `p` 就會完成 `paste_from_clipboard`。
cut 个操作嘛仝款，先隨个仔 `x` 才 `p`。伊干焦提供即兩種「多檔案操作」。
若是 delete，干焦會使單獨揤 `d`，單獨做確認。

伊有 `m` (move) 指令，但是無正常，無法度做正常个徒動檔案入去次目錄，
干要會使做出親像 rename 个效果。

問 Warp AI claude 4.1，閣問 chatgtp 攏報毋著路，問 gemini 才得著正解。

## selene 兩个設定檔个關係

一直毋知 AstroNvim 佇 ~/.config/nvim 下底創兩个設定檔 selene.toml
佮 neovim.yml 个作用，問 Warp AI 才知：

> The ./neovim.yml file is used by Selene, the Lua linter.
>
> This is a Selene standard library definition file that defines the vim global
> variable as valid for Neovim Lua code. When selene.toml specifies
> `std ="neovim"`, Selene looks for a file named neovim.yml in the same
> directory to understand what globals and APIs are available in the Neovim
> environment.
>
> The file tells Selene that:
>
> - The base Lua version is Lua 5.1 (base: lua51)
> - The vim global variable exists and can be of any type (vim: any: true)
>
> This prevents Selene from incorrectly flagging vim.\* calls as undefined
> globals when linting your Neovim Lua configuration files.

## 重裝、重整 AstroNvim

`lua_ls` 又閣袂認得 `---@type LazySpec` 矣！重裝 AstroNvim，隨个仔隨个將 plugin
崁轉來，過程中做寡檢討，親像 markdown 就採用 community.pack.markdown 做基礎，
刪除無效个 prettiered/prettier，改用 mdformt 佮 cbfmt 配合 conform 看有法度處理
range formatting 無？

補充說明進前就有裝个 bash pack，寫佇 git commit log

Lua pack will install lua_ls, selene & stylua. Bash pack will install
bash-language-server(bashls), shellcheck(as linter & formatter) & shfmt(as
formatter) and bash-debug-adapter. `bashls` can handle "sh", "bash" & "zsh"
filetypes.

### cbfmt 安裝、測試

Warp AI 建置 `~/.cbfmt.toml`, 修改 `plugins/markdown.lua`，創測試檔
`../test/test-cbfmt.md`。

#### Warp AI Summary

✅ cbfmt will now work everywhere, including when you edit ~/Hak/08172025.md in
nvim, because:

1. Config location fixed: I moved .cbfmt.toml from `~/.config/nvim/` to your
   home directory (`~/.cbfmt.toml`). This makes it globally available - cbfmt
   searches for config files in the current directory and all parent directories
   up to the root.
2. Nvim integration updated: Modified your markdown.lua to use cbfmt for
   markdown files. Now when you format markdown files in nvim (using whatever
   keybinding you have for formatting, likely <leader>lf or similar), it will:
   - First run cbfmt to format code blocks
   - Then run mdformat to format the markdown structure
3. Mason integration: Since cbfmt is installed via Mason, conform.nvim should
   automatically find it in Mason's bin directory.

To use in nvim:

- Open any markdown file: nvim ~/Hak/08172025.md
- Format the file using your format keybinding (check with :ConformInfo to see
  the active formatters)
- The code blocks will be formatted by cbfmt using the rules in ~/.cbfmt.toml

To use from command line: bash The configuration will work for lua, bash, sh,
and zsh code blocks. When you want to add Python support, just install black and
uncomment those lines in ~/.cbfmt.toml.

#### markdown formatters

cbfmt 透過 ~/.cbfmt.toml 設定。mdformt 透過 plugins/markdown.lua 內底匯入
conform.nvim 來指定執行參數，結局嘛是無法度處理漢字長行。

```lua
  {
    "stevearc/conform.nvim",
    optional = true,
    opts = {
      formatters_by_ft = {
        -- Use cbfmt for formatting code blocks, then mdformat for the markdown structure
        -- Both will run in sequence when formatting
        -- Khoguan: cbfmt uses ~/.cbfmt.toml
        markdown = { "cbfmt", "mdformat" },
      },
      formatters = {
        mdformat = {
          -- prepend_args = { "--number", "--wrap", "80" },
          prepend_args = { "--number" }, -- 有漢字，行長算袂準
        },
      },
    },
  },
}
```
