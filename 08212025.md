# 2025-08-21 學習日誌

- [ ] astrocore 試用 opt.wo
- [x] tokyonight 色水再精進
- [ ] various default nvim & AstroNvim keymaps
- [ ] nvim vertical windows separator
- [ ] 考慮用 luacheck 取代 selene

## astrocore 試用 opt.wo

無效。

## tokyonight 色水再精進

```lua
on_highlights = function(highlights, colors)
  local util = require "tokyonight.util"
  local md_inline_bg = highlights["@markup.raw.markdown_inline"].bg
  local md_inline_fg = highlights["@markup.raw.markdown_inline"].fg
  highlights["@markup.raw.markdown_inline"] = {
    bg = util.darken(md_inline_bg, 0.3), -- 0~1 darkest to original
    fg = util.lighten(md_inline_fg, 0.3), -- 0~1 lightest to original
  }
```

## various default nvim & AstroNvim keymaps

`/opt/homebrew/Cellar/neovim/0.11.3/share/nvim/runtime/lua/vim/_defaults.lua`
內底有真濟對我有路用个預設 nvim keymaps 佮定義。規个 neovim 目錄下底干焦一个
檔案號做 `_defaults.lua`。

vim default `Y` 指令是 yank the whole line，nvim 佇遮共伊改做 yank from
the current cursor position to EOL，是為著欲佮 `C`, `D` 行為一致。咱若較愛保留
舊行為，會使家己做 `:lua vim.keymap.del('n', 'Y')`。

## nvim vertical windows separator

兩个垂直視窗个分隔

AstroNvim 兩个垂直視窗个分隔線佇 dark mode 个時看袂分明，欲拖動咧調整雙爿視窗
闊度無利便，`fillchars` option 內底有 `vert` key 通添，試試咧無路益，後來改行
別條路，設 keymap 來調整闊度、針對無仝 filetype 設無仝主題、佇主題个 opts 指定
dim_inactive = true，予雙爿視窗光度有差別，遮个攏有幫贈。

AstroNvim default keymaps for resizing vertical windows are <C-Left> and
<C-Right>, but they conflict with MacOS default keybindings for navigating to
left or right vertual desktops and then they won't work in Neovim. I copy the
definitions and use the keycodes `<C-,>` and `<C-.>` to make current vertical
window narrower and wider by step of 2.

## 考慮用 luacheck 取代 selene

Warp AI 說明兩者个差別：

Compare the two Lua linters selene and luacheck?

I'll compare the two popular Lua linters, Selene and Luacheck, to help you
understand their differences and strengths.

### **Selene vs Luacheck Comparison**

#### **Selene**

- **Written in:** Rust
- **Performance:** Very fast due to Rust implementation
- **Configuration:** Uses TOML files (`selene.toml`)
- **Roblox Support:** Excellent built-in support for Roblox Lua
- **Standard Library:** Configurable via YAML files for custom environments
- **Modern Features:** Actively developed with modern tooling approach
- **Error Messages:** Clear, colored output with good formatting
- **Installation:** Via cargo, pre-built binaries, or package managers

#### **Luacheck**

- **Written in:** Pure Lua
- **Performance:** Slower than Selene but still reasonable
- **Configuration:** Uses `.luacheckrc` (Lua-based config)
- **Maturity:** More mature, widely adopted in the Lua community
- **Inline Directives:** Excellent support for inline comments to control linting
- **Integration:** Better integration with older Lua toolchains
- **Custom Rules:** More flexible for writing custom lint rules
- **Installation:** Via LuaRocks, package managers, or standalone

#### **Key Differences**

| Feature                        | Selene                   | Luacheck                    |
| ------------------------------ | ------------------------ | --------------------------- |
| **Speed**                      | Much faster (10-100x)    | Slower but acceptable       |
| **Memory Usage**               | Lower                    | Higher                      |
| **Config Format**              | TOML/YAML                | Lua                         |
| **Neovim Integration**         | Good via null-ls/none-ls | Excellent, widely supported |
| **Custom Standards**           | YAML-based               | Lua-based                   |
| **Undefined Global Detection** | Good                     | Excellent                   |
| **Unused Variable Detection**  | Good                     | Excellent with more options |
| **Type Checking**              | Basic                    | Basic                       |
| **Project Maturity**           | Newer (2019+)            | Mature (2014+)              |

#### **Strengths**

**Selene is better for:**

- Large codebases where speed matters
- Roblox Lua development
- Modern toolchain integration
- Projects preferring TOML configuration

**Luacheck is better for:**

- Traditional Lua projects
- Projects needing fine-grained inline control
- Complex custom rule requirements
- Maximum compatibility with existing tools

#### **For Neovim Configuration**

Since you're working with Neovim configurations:

- **Luacheck** has more mature Neovim integration and is widely used for linting
  Neovim Lua configs
- **Selene** works well but may need additional configuration for
  Neovim-specific globals
- Both can be integrated via:
  - `null-ls.nvim` / `none-ls.nvim`
  - `nvim-lint`
  - Native LSP diagnostics

#### **Example Configurations**

**Selene (`selene.toml`):**

```toml
std = "lua51+vim"
exclude = ["tests/**/*.lua"]

[rules]
global_usage = "warn"
unused_variable = "warn"
```

**Luacheck (`.luacheckrc`):**

```lua
return {
  globals = { "vim" },
  ignore = { "212", "213" },
  max_line_length = 120,
}
```

#### **Recommendation**

- Use **Selene** if you want modern, fast tooling and don't need complex custom
  rules
- Use **Luacheck** if you need maximum compatibility, mature ecosystem support,
  or complex inline directives

For Neovim configuration specifically, Luacheck might be slightly better due to
its maturity and widespread adoption in the Neovim community, but Selene is
perfectly capable and significantly faster.
