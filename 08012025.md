# 2025-08-01 å­¸ç¿’æ—¥èªŒ

- [X] ä¸»é¡Œåˆ‡æ›ï¼šmd ç”¨ tokyonight, å…¶ä»– ç”¨ night-owl - å‹‰å¼·éé—œ
- [X] è©¦ç”¨ astroui folding - æœƒç”¨å¾—ä¸ªæ™‚å‹‰å¼·éé—œï¼Œä½†æ˜¯å®šå®šå¤±éˆ
- [X] åˆä½µ .zprofile ä½® .zshrc
- [X] æ¯”è¼ƒ heirline ä½® lualine
- [X] æ”¹ç”¨ AstroNvim åšåº•
- [X] AstroNvim + render-markdown + tokyonight + styler åˆæ­¥æˆåŠŸ

NOTE: ä»Šä»”æ—¥ä¸ªæ„Ÿæƒ³ï¼šäº”è‰²ä»¤äººç›®ç›²ï¼Œç•«é¢å‰µç”²å‚·èŠ±ï¼Œå‚·ç›®ç­ã€å‚·å…ƒæ°£ï¼Œæ¯‹å€¼ã€‚
render-markdown è¨­å®šè¦å·¥ï¼Œå˜›è¢‚å‡å…¨ç„¶æ»¿æ„ï¼Œæš«åœä¹Ÿå¥½ã€‚folding ç¸½ç®—è¨­åˆ°æœƒç”¨å¾—ä¸ª
ç¨‹åº¦ã€‚

## MD ä¸»é¡Œç”¨ tokyonightï¼Œå…¶ä»–ç”¨ night-owl

### Warp AI è§£æ³•

ä»¥ä¸‹æ˜¯ Warp AI æä¾›ï¼š

---
Here's how you can implement Method 3 for your specific scenario - using
`tokyonight` for markdown files and `night-owl` for everything else:

#### First version

```lua
-- Set night-owl as the default colorscheme
vim.cmd.colorscheme("night-owl")

-- Create an autocommand group for colorscheme switching
local colorscheme_group = vim.api.nvim_create_augroup("FiletypeColorscheme",
  { clear = true })

-- Switch to tokyonight for markdown files
vim.api.nvim_create_autocmd("FileType", {
  group = colorscheme_group,
  pattern = { "markdown", "md" },
  callback = function()
    vim.cmd.colorscheme("tokyonight")
  end,
})

-- Switch back to night-owl for non-markdown files
vim.api.nvim_create_autocmd("FileType", {
  group = colorscheme_group,
  pattern = "*",
  callback = function()
    local ft = vim.bo.filetype
    -- Only switch if it's not markdown
    if ft ~= "markdown" and ft ~= "md" then
      vim.cmd.colorscheme("night-owl")
    end
  end,
})
```

#### Alternative approach (more explicit):

If you want more control and to avoid potential conflicts:

```lua
-- Set default colorscheme
vim.cmd.colorscheme("night-owl")

local function switch_colorscheme()
  local ft = vim.bo.filetype

  if ft == "markdown" or ft == "md" then
    vim.cmd.colorscheme("tokyonight")
  else
    vim.cmd.colorscheme("night-owl")
  end
end

-- Create autocommand group
local colorscheme_group = vim.api.nvim_create_augroup("FiletypeColorscheme",
  { clear = true })

-- Switch colorscheme on file type detection and buffer enter
vim.api.nvim_create_autocmd({ "FileType", "BufEnter" }, {
  group = colorscheme_group,
  callback = switch_colorscheme,
})
```

#### Even more robust version:

```lua
-- Track current colorscheme to avoid unnecessary switches
local current_colorscheme = "night-owl"
vim.cmd.colorscheme(current_colorscheme)

local function smart_colorscheme_switch()
  local ft = vim.bo.filetype
  local target_colorscheme

  if ft == "markdown" or ft == "md" then
    target_colorscheme = "tokyonight"
  else
    target_colorscheme = "night-owl"
  end

  -- Only switch if different from current
  if target_colorscheme ~= current_colorscheme then
    vim.cmd.colorscheme(target_colorscheme)
    current_colorscheme = target_colorscheme
  end
end

local colorscheme_group = vim.api.nvim_create_augroup("FiletypeColorscheme",
  { clear = true })

vim.api.nvim_create_autocmd({ "FileType", "BufEnter" }, {
  group = colorscheme_group,
  callback = smart_colorscheme_switch,
})
```

The third version is the most efficient as it avoids unnecessary colorscheme
reloads when switching between buffers of the same type.

---

NOTE: åˆ‡æ›äº†æ‡‰è©²æ˜¯æœ‰æˆåŠŸï¼Œä¸è€Œéä¸€æ—¦å«å…¥ MD æª”äº†å¾Œï¼Œé–£åˆ‡é lua æª”ï¼Œ `:colorscheme`
çŒ¶åŸæœƒä¸€ç›´é¡¯ç¤ºæ˜¯ tokyonightã€‚

### folke/styler.nvim è§£æ³•

ä½‡ init.lua æŒ‡å®šä¸»è¦ä¸»é¡Œ night-owlï¼Œå¦å¤–ä½‡ plugins/styler.lua æŒ‡å®š MD æ‰€ç”¨ä¸ªä¸»é¡Œ
tokyonight-nightã€‚è©¦äº†æ•¢å“ªæœ‰æˆåŠŸï¼Œä½†æ˜¯`:colorscheme`æœƒæ”è®Šåš`default`ã€‚

styler.nivm æœ‰æä¾›`:Styler`æŒ‡ä»¤é€šæ‰‹å‹•åˆ‡æ›ä¸»é¡Œï¼Œé›–ç„¶æ›æœƒéï¼Œä½†æ˜¯`:colorscheme`
ä»æ¬¾æ”é¡¯ç¤º`default`ã€‚ä½†æ˜¯ Styler æœƒä½¿é‡å°æ¯ä¸€ä¸ª buffer è¨­å®šç„¡ä»ä¸»é¡Œï¼Œæ‰€ä»¥æ¯‹æ˜¯
colorscheme ä¸ªåŒç¾©è©ã€‚

## astroui folding

1. ç›´æ¥ copy
`~/.local/share/nvim-astro/lazy/AstroNvim/lua/astronvim/plugins/_astroui.lua`
` ä¾†ç”¨ã€‚
2. æ„›é–£ copy `_astrotheme`ã€‚

## åˆä½µ .zprofile ä½® .zshrc

å« Warp AI å°‡ .zprofile ç›¡é‡æ¸…äºˆç©ºï¼Œä¸€å¯¡è¨­å®šæ”é›†ä¸­ä¾† .zshrc ç®¡ç†ã€‚

---
I've successfully consolidated everything from your .zprofile into your .zshrc
file. Here's what I accomplished:

âœ… Consolidation Complete

Key Changes Made:

1. Moved all content from .zprofile to .zshrc:
   -  add_to_path() function (removed duplicate)
   -  NODE_PATH environment variable 
   -  CDPATH with your Google Drive path
   -  All other environment variables
2. Standardized locale settings:
   -  Set both LANG=en_US.UTF-8 and LC_ALL=en_US.UTF-8 as requested
   -  Resolved the inconsistency where .zprofile used zh_TW.UTF-8
3. Cleaned up .zprofile:
   -  Now contains only a minimal configuration that sources .zshrc for login shells
   -  This ensures compatibility while keeping everything centralized
4. Updated the classification document:
   -  Documents all changes made and duplicates resolved
   -  Provides next steps for testing

What to do next:

1. Test your configuration by opening a new terminal window
2. Verify that all your aliases, functions, and environment variables work
   correctly
3. Check that your PATH, CDPATH, and other settings are properly loaded

The consolidation maintains full functionality while eliminating duplicates and
inconsistencies. Your shell configuration is now centralized in .zshrc with the
requested English locale settings.

## æ¯”è¼ƒ heirline ä½® lualine

**Warp AI å›ç­”**

Based on my research, here's a comprehensive comparison between
**heirline.nvim** and **lualine.nvim**:

### **Overview**

#### **lualine.nvim**
- **Stars**: 7,239 â­ (significantly more popular)
- **Description**: "A blazing fast and easy to configure neovim statusline
  plugin written in pure lua"
- **Created**: December 2020 (older, more established)
- **Philosophy**: Plug-and-play with sensible defaults

#### **heirline.nvim** 
- **Stars**: 1,167 â­ (smaller but dedicated community)
- **Description**: "A no-nonsense Neovim Statusline plugin designed around
  recursive inheritance to be exceptionally fast and versatile"
- **Created**: January 2022 (newer)
- **Philosophy**: Maximum customization and performance through programmatic
  configuration

### **Key Differences**

#### **ğŸ“Š Configuration Approach**

**lualine.nvim** - **Declarative & Simple**
- Uses a straightforward table-based configuration
- Pre-built components and themes
- Minimal setup required
- Example: `opts = { theme = 'gruvbox', sections = { lualine_a = {'mode'} } }`

**heirline.nvim** - **Programmatic & Flexible**
- Components are built as nested Lua tables with recursive inheritance
- Everything is a "component" - from text to complex widgets
- Requires more Lua knowledge but offers unlimited flexibility
- Example: Components are defined as functions that return tables with provider,
  hl, condition, etc.

#### **ğŸ¨ Customization Level**

**lualine.nvim**
- âœ… Easy theming with built-in themes
- âœ… Pre-made components (git branch, diagnostics, etc.)
- âœ… Simple section-based layout
- âŒ Limited layout flexibility
- âŒ Harder to create completely custom components

**heirline.nvim**
- âœ… Complete control over every pixel
- âœ… Dynamic layouts and conditional rendering
- âœ… Can create statusline, winbar, tabline all with one plugin
- âœ… Extremely efficient component system
- âŒ Steeper learning curve
- âŒ No built-in themes (you build everything yourself)

#### **âš¡ Performance**

**Both are fast**, but heirline has architectural advantages:
- **heirline**: Designed around performance with minimal redraws and efficient caching
- **lualine**: Very fast for most use cases, but may do more work for complex setups

#### **ğŸ“š Learning Curve**

**lualine.nvim**: â­â­ (Easy)
- Works out of the box
- Similar to vim-airline configuration
- Great documentation with examples

**heirline.nvim**: â­â­â­â­ (Advanced)
- Requires understanding of component architecture
- Need to build everything from scratch
- More Lua programming required

#### **ğŸŒŸ Use Cases**

**Choose lualine.nvim if you:**
- Want a statusline that works immediately
- Prefer pre-built components and themes
- Don't need heavily customized layouts
- Want something battle-tested and widely used
- Are new to Neovim/Lua configuration

**Choose heirline.nvim if you:**
- Want maximum control over appearance and behavior
- Enjoy building custom components
- Need dynamic layouts or complex conditional logic
- Want to create statusline, winbar, and tabline with one plugin
- Value performance optimization
- Are comfortable with advanced Lua programming

### **Current Status**

I can see you currently have lualine.nvim installed in your configuration with
minimal setup (`opts = {}`), which means you're using the default configuration.
This is perfect for getting started quickly!

### **Recommendation**

For most users, **lualine.nvim** is the better choice due to its ease of use and
extensive community support. However, if you're an advanced user who wants
complete control over your statusline and enjoys the programming aspect,
**heirline.nvim** offers unmatched flexibility and performance.

Would you like me to show you how to enhance your current lualine configuration
or help you explore what a heirline setup might look like?

## æ”¹ç”¨ AstroNvim åšåº•

å› ç‚º folding ä¸€ç›´è¨­è¢‚å‘¨è‡³ï¼Œå³é¦¬æ”¹ç”¨ AstroNvim åšåŸºç¤ï¼ŒthaÌhæˆ‘ä¸ªæ ¸å¿ƒè¨­å®šä½®æ’ä»¶ï¼Œ
åŒæ™‚ä¹Ÿå»æ’ä¸€å¯¡ AstroNvim ä¸ªå®¶å©†è¨­å®šï¼Œè¦ªåƒ MD ä¸ªè‡ªå‹•å®ŒæˆåŠŸèƒ½ï¼ˆè£œå……ï¼šç”¨ toggle
keymap å°±å¥½ï¼‰ã€‚

ç¶“éæ¿Ÿæ¿Ÿæ“ºè©¦ç”¨é–£è©¦ç”¨ï¼Œä»Šé–£ç¿»é ­ä¾†ç”¨ AstroNvimï¼ŒåŠ è¶³æœ‰æ¦‚å¿µçŸ£ï¼ä¸»é¡Œæ›éä¾† night-owlï¼Œ
comment è‰²æ°´æ”¹è¼ƒé¡¯ç›®ï¼Œå…¶ä»–ä¸ª highlight è¨­å®šä¹Ÿæ”ä½‡ astroui.lua å…§åº•åšã€‚
è‡ªå‹•å®ŒæˆåŠŸèƒ½æœƒä½¿ `<leader>uc` ç¦khÃ iã€‚æˆ‘å®¶å·±ä¸ªä¸‰å¤§è¨­å®šæª”è¼•é¬†å¼•é€²å…¥ä¾†ï¼Œå¹²ç„¦ä¿®æ”¹
keymaps.lua å…§åº• require("Comment.api") é€²å‰å…ˆ pcall ç¢ºèªã€‚

å®Œæˆåº¦çœŸæ‡¸ä¸ª folding æ‹—é€è¨­å®šæ˜¯æˆ‘ä¸Šå¤§ä¸ªæ”¶ç›Šï¼å°‡ä¸€å¤§å † AI å›æ‡‰æ”æ”¶èµ·ä¾†ï¼ŒæŒ‰å‘¢ä¾†ç·¨å¯«
å­¸ç¿’æ—¥èªŒæ‰æœƒè¼•å¯å•¦ï¼

AstroNvim æœƒè¨˜å¾—é ‚æ“ºä¸ªæ¸¸æ¨™ä½ç½®ï¼ä¼Šä¹Ÿæœ‰æä¾› Zen modeï¼Œæ¸›å°‘è¦–è¦ºè½Ÿç‚¸ã€‚

AstroNvim + render-markdown + tokyonight theme + styler ä¸ªçµ„åˆé‹ç”¨ï¼Œåˆæ­¥æˆåŠŸï¼
æŒ‡ä»¤ `RenderMarkdown buf_disable` ä½® `RenderMarkdown buf_enable` å°±æœƒä½¿é—œï¼é–‹
ç›®å‰ä¸ªbufferçŸ£ï¼Œç•¶ç„¶ä¹Ÿæœ‰ global ä¸ª disable/enable ç‰ˆã€‚
